name: Build Soi's Tetris (one-file workflow)

on:
  workflow_dispatch:
  push:
    branches: [ main, master ]
    paths:
      - ".github/workflows/android.yml"

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      # 1) (기존 그대로) 안드로이드 프로젝트 파일 생성
      - name: Write Android project files
        shell: bash
        run: |
          set -e
          # ⬇️ 여기부터는 기존 yml에 있던 cat > ... 내용 그대로 붙여넣기
          mkdir -p app/src/main/java/com/soi/tetris
          mkdir -p app/src/main/res/layout
          mkdir -p app/src/main/res/values
          mkdir -p app/src/main/res/mipmap-anydpi-v26
          cat > settings.gradle.kts <<'EOF'
          rootProject.name = "SoiTetris"
          include(":app")
          EOF
          cat > build.gradle.kts <<'EOF'
          plugins {
            id("com.android.application") version "8.7.0" apply false
            id("org.jetbrains.kotlin.android") version "1.9.24" apply false
          }
          EOF
          cat > app/build.gradle.kts <<'EOF'
          plugins {
            id("com.android.application")
            id("org.jetbrains.kotlin.android")
          }
          android {
            namespace = "com.soi.tetris"
            compileSdk = 35
            defaultConfig {
              applicationId = "com.soi.tetris"
              minSdk = 24
              targetSdk = 35
              versionCode = 1
              versionName = "1.0"
            }
            buildTypes {
              release {
                isMinifyEnabled = false
                proguardFiles(
                  getDefaultProguardFile("proguard-android-optimize.txt"),
                  "proguard-rules.pro"
                )
              }
              debug { isMinifyEnabled = false }
            }
            compileOptions {
              sourceCompatibility = JavaVersion.VERSION_17
              targetCompatibility = JavaVersion.VERSION_17
            }
            kotlinOptions { jvmTarget = "17" }
          }
          dependencies {
            implementation("androidx.core:core-ktx:1.13.1")
            implementation("androidx.appcompat:appcompat:1.7.0")
            implementation("com.google.android.material:material:1.12.0")
          }
          EOF
          cat > app/proguard-rules.pro <<'EOF'
          # No special rules needed.
          EOF
          cat > app/src/main/AndroidManifest.xml <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <manifest xmlns:android="http://schemas.android.com/apk/res/android"
              package="com.soi.tetris">
            <application
                android:allowBackup="true"
                android:icon="@mipmap/ic_launcher"
                android:label="@string/app_name"
                android:roundIcon="@mipmap/ic_launcher_round"
                android:supportsRtl="true"
                android:theme="@style/Theme.SoiTetris">
              <activity
                  android:name=".MainActivity"
                  android:exported="true"
                  android:screenOrientation="portrait">
                <intent-filter>
                  <action android:name="android.intent.action.MAIN" />
                  <category android:name="android.intent.category.LAUNCHER" />
                </intent-filter>
              </activity>
            </application>
          </manifest>
          EOF
          cat > app/src/main/res/layout/activity_main.xml <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:background="@color/board_bg">
            <com.soi.tetris.GameView
                android:id="@+id/gameView"
                android:layout_width="match_parent"
                android:layout_height="match_parent" />
          </FrameLayout>
          EOF
          cat > app/src/main/res/values/strings.xml <<'EOF'
          <resources>
              <string name="app_name">Soi&#39;s Tetris</string>
          </resources>
          EOF
          cat > app/src/main/res/values/colors.xml <<'EOF'
          <resources>
              <color name="black">#000000</color>
              <color name="white">#FFFFFF</color>
              <color name="board_bg">#121212</color>
              <color name="text_primary">#FFFFFF</color>
          </resources>
          EOF
          cat > app/src/main/res/values/themes.xml <<'EOF'
          <resources xmlns:tools="http://schemas.android.com/tools">
              <style name="Theme.SoiTetris" parent="Theme.MaterialComponents.DayNight.NoActionBar">
                  <item name="android:statusBarColor">@color/board_bg</item>
                  <item name="android:navigationBarColor">@color/board_bg</item>
                  <item name="android:windowBackground">@color/board_bg</item>
                  <item name="android:windowLayoutInDisplayCutoutMode">shortEdges</item>
              </style>
          </resources>
          EOF
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@android:color/black"/>
              <foreground android:drawable="@android:color/white"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
              <background android:drawable="@android:color/black"/>
              <foreground android:drawable="@android:color/white"/>
          </adaptive-icon>
          EOF
          cat > app/src/main/java/com/soi/tetris/MainActivity.kt <<'EOF'
          package com.soi.tetris
          import android.os.Bundle
          import androidx.appcompat.app.AppCompatActivity
          class MainActivity : AppCompatActivity() {
            override fun onCreate(savedInstanceState: Bundle?) {
              super.onCreate(savedInstanceState)
              setContentView(R.layout.activity_main)
            }
          }
          EOF
          cat > app/src/main/java/com/soi/tetris/GameView.kt <<'EOF'
          package com.soi.tetris
          import android.content.Context
          import android.graphics.*
          import android.util.AttributeSet
          import android.view.MotionEvent
          import android.view.SurfaceHolder
          import android.view.SurfaceView
          import kotlin.math.abs
          import kotlin.random.Random
          class GameView @JvmOverloads constructor(
            context: Context, attrs: AttributeSet? = null
          ) : SurfaceView(context, attrs), SurfaceHolder.Callback, Runnable {
            private var thread: Thread? = null
            @Volatile private var running = false
            private val cols = 10
            private val rows = 20
            private val board = Array(rows) { IntArray(cols) { 0 } }
            private var cellSize = 0f
            private var offsetX = 0f
            private var offsetY = 0f
            private val paint = Paint(Paint.ANTI_ALIAS_FLAG)
            private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
              color = Color.WHITE
              textSize = 48f
              typeface = Typeface.create(Typeface.MONOSPACE, Typeface.BOLD)
            }
            private val titlePaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {
              color = Color.WHITE
              textSize = 58f
              typeface = Typeface.create(Typeface.DEFAULT_BOLD, Typeface.BOLD)
            }
            private val shapes = arrayOf(
              arrayOf(intArrayOf(0,0,0,0),intArrayOf(1,1,1,1),intArrayOf(0,0,0,0),intArrayOf(0,0,0,0)),
              arrayOf(intArrayOf(2,0,0),intArrayOf(2,2,2),intArrayOf(0,0,0)),
              arrayOf(intArrayOf(0,0,3),intArrayOf(3,3,3),intArrayOf(0,0,0)),
              arrayOf(intArrayOf(4,4),intArrayOf(4,4)),
              arrayOf(intArrayOf(0,5,5),intArrayOf(5,5,0),intArrayOf(0,0,0)),
              arrayOf(intArrayOf(0,6,0),intArrayOf(6,6,6),intArrayOf(0,0,0)),
              arrayOf(intArrayOf(7,7,0),intArrayOf(0,7,7),intArrayOf(0,0,0))
            )
            private val colors = intArrayOf(
              Color.TRANSPARENT, Color.parseColor("#00BCD4"), Color.parseColor("#3F51B5"),
              Color.parseColor("#FF9800"), Color.parseColor("#FFEB3B"),
              Color.parseColor("#4CAF50"), Color.parseColor("#9C27B0"), Color.parseColor("#F44336")
            )
            private data class Piece(var matrix: Array<IntArray>, var x: Int, var y: Int)
            private var current: Piece = spawnPiece()
            private var nextPieceMatrix: Array<IntArray> = randomShape()
            private var fallTimer = 0L
            private var fallInterval = 550L
            private var score = 0
            private var gameOver = false
            private var downX = 0f
            private var downY = 0f
            private var moved = false
            init {
              holder.addCallback(this)
              setOnTouchListener { _, event -> handleTouch(event); true }
            }
            private fun randomShape(): Array<IntArray> { val s = shapes[Random.nextInt(shapes.size)]; return Array(s.size){r->s[r].clone()} }
            private fun spawnPiece(): Piece { val m = nextPieceMatrix; nextPieceMatrix = randomShape(); val startX = cols/2 - m[0].size/2; return Piece(m, startX, 0) }
            private fun rotate(matrix: Array<IntArray>): Array<IntArray> { val h=matrix.size; val w=matrix[0].size; val out=Array(w){IntArray(h)}; for(y in 0 until h) for(x in 0 until w) out[x][h-1-y]=matrix[y][x]; return out }
            private fun collides(p: Piece, nx: Int=p.x, ny: Int=p.y, mat: Array<IntArray>=p.matrix): Boolean {
              val h=mat.size; val w=mat[0].size
              for (y in 0 until h) for (x in 0 until w) {
                if (mat[y][x]!=0) {
                  val bx=nx+x; val by=ny+y
                  if (bx<0||bx>=cols||by>=rows) return true
                  if (by>=0 && board[by][bx]!=0) return true
                }
              }
              return false
            }
            private fun lockPiece(p: Piece) {
              val h=p.matrix.size; val w=p.matrix[0].size
              for (y in 0 until h) for (x in 0 until w) {
                val v=p.matrix[y][x]
                if (v!=0) {
                  val by=p.y+y
                  if (by<0) gameOver=true else board[by][p.x+x]=v
                }
              }
              clearLines()
              current=spawnPiece()
              if (collides(current)) gameOver=true
            }
            private fun clearLines() {
              var cleared=0; var r=rows-1
              while (r>=0) {
                var full=true
                for (c in 0 until cols) if (board[r][c]==0){full=false;break}
                if (full){ for (y in r downTo 1) board[y]=board[y-1].clone(); board[0]=IntArray(cols){0}; cleared+=1 }
                else r-=1
              }
              if (cleared>0){ score += when(cleared){1->100;2->300;3->500;else->800}; fallInterval=(fallInterval*0.96).toLong().coerceAtLeast(120L) }
            }
            private fun softDrop(){ if(!collides(current,current.x,current.y+1)){ current.y+=1; score+=1 } else lockPiece(current) }
            private fun move(dx: Int){ val nx=current.x+dx; if (!collides(current,nx,current.y)) current.x=nx }
            private fun tryRotate(){
              val rot=rotate(current.matrix)
              if(!collides(current,current.x,current.y,rot)){ current.matrix=rot; return }
              if(!collides(current,current.x-1,current.y,rot)){ current.x-=1; current.matrix=rot; return }
              if(!collides(current,current.x+1,current.y,rot)){ current.x+=1; current.matrix=rot; return }
            }
            private fun handleTouch(ev: MotionEvent){
              when(ev.actionMasked){
                MotionEvent.ACTION_DOWN -> { downX=ev.x; downY=ev.y; moved=false }
                MotionEvent.ACTION_MOVE -> {
                  val dx=ev.x-downX; val dy=ev.y-downY
                  if(!moved && kotlin.math.abs(dx)>40){ moved=true; if(dx>0) move(1) else move(-1); downX=ev.x; downY=ev.y }
                  if(dy>50){ softDrop(); downY=ev.y }
                }
                MotionEvent.ACTION_UP -> { val dx=ev.x-downX; val dy=ev.y-downY; if(kotlin.math.abs(dx)<20 && kotlin.math.abs(dy)<20) tryRotate() }
              }
            }
            override fun surfaceCreated(holder: SurfaceHolder){ running=true; thread=Thread(this).also{it.start()} }
            override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {}
            override fun surfaceDestroyed(holder: SurfaceHolder){ running=false; try{ thread?.join(500) } catch(_:InterruptedException){} }
            override fun run(){
              var last=System.currentTimeMillis()
              while(running){
                val now=System.currentTimeMillis(); val dt=now-last; last=now
                update(dt); drawFrame()
                try{ Thread.sleep(16) } catch(_:InterruptedException){}
              }
            }
            private fun update(dt: Long){ if(gameOver) return; fallTimer+=dt; if(fallTimer>=fallInterval){ fallTimer=0L; softDrop() } }
            private fun drawFrame(){
              val canvas=holder.lockCanvas() ?: return
              try{
                canvas.drawColor(Color.parseColor("#101418"))
                val w=width.toFloat(); val h=height.toFloat()
                val boardWidth=(w*0.7f)
                cellSize=(boardWidth/cols)
                val boardHeight=cellSize*rows
                offsetX=(w-boardWidth)/2f
                offsetY=(h-boardHeight)/2f + 60f
                titlePaint.textAlign=Paint.Align.CENTER
                canvas.drawText("Soi's Tetris", w/2f, 70f, titlePaint)
                textPaint.textAlign=Paint.Align.LEFT
                canvas.drawText("Score: $score", offsetX, offsetY-20f, textPaint)
                val previewSize=cellSize*4
                val previewLeft=offsetX+boardWidth+12f
                val previewTop=offsetY
                paint.style=Paint.Style.STROKE; paint.strokeWidth=3f; paint.color=Color.WHITE
                canvas.drawRect(previewLeft, previewTop, previewLeft+previewSize, previewTop+previewSize, paint)
                textPaint.textAlign=Paint.Align.LEFT
                canvas.drawText("Next", previewLeft, previewTop-10f, textPaint)
                drawMatrix(canvas, nextPieceMatrix, previewLeft, previewTop, cellSize)
                paint.style=Paint.Style.FILL
                paint.color=Color.parseColor("#0B0F12")
                canvas.drawRect(offsetX-4, offsetY-4, offsetX + cellSize*cols + 4, offsetY + cellSize*rows + 4, paint)
                for (y in 0 until rows) for (x in 0 until cols) drawCell(canvas, x, y, board[y][x])
                drawMatrix(canvas, current.matrix, offsetX + current.x*cellSize, offsetY + current.y*cellSize, cellSize, boardCoords = true)
                if (gameOver){
                  val msg="GAME OVER\nTap to restart"
                  textPaint.textAlign=Paint.Align.CENTER
                  textPaint.textSize=56f
                  var yy=h/2f - 30f
                  for (line in msg.split("\n")) { canvas.drawText(line, w/2f, yy, textPaint); yy += 64f }
                }
              } finally { holder.unlockCanvasAndPost(canvas) }
            }
            private fun drawCell(canvas: Canvas, x: Int, y: Int, value: Int){
              val left=offsetX + x*cellSize
              val top=offsetY + y*cellSize
              val right=left + cellSize
              val bottom=top + cellSize
              paint.style=Paint.Style.STROKE; paint.strokeWidth=1f; paint.color=Color.parseColor("#1F2A33")
              canvas.drawRect(left, top, right, bottom, paint)
              if(value!=0){
                paint.style=Paint.Style.FILL; paint.color=colors[value]
                canvas.drawRect(left+2, top+2, right-2, bottom-2, paint)
                paint.color=Color.argb(90,255,255,255)
                canvas.drawRect(left+2, top+2, right-10, top+10, paint)
              }
            }
            private fun drawMatrix(canvas: Canvas, matrix: Array<IntArray>, left: Float, top: Float, size: Float, boardCoords: Boolean=false){
              val h=matrix.size; val w=matrix[0].size
              var ox=left; var oy=top
              if(!boardCoords){
                val cx=(4-w)*0.5f; val cy=(4-h)*0.5f
                ox += cx*size; oy += cy*size
              }
              for (y in 0 until h) for (x in 0 until w) {
                val v=matrix[y][x]
                if (v!=0){
                  paint.style=Paint.Style.FILL; paint.color=colors[v]
                  val l=ox + x*size; val t=oy + y*size
                  val r=l + size; val b=t + size
                  canvas.drawRect(l+2, t+2, r-2, b-2, paint)
                  paint.color=Color.argb(90,255,255,255)
                  canvas.drawRect(l+2, t+2, r-10, t+10, paint)
                }
              }
            }
          }
          EOF
          echo "Project files created:"
          ls -R

      # 2) JDK 17 명시 (에러 원인 해결)
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: '17'
          cache: 'gradle'

      # 3) Android SDK 설치
      - name: Set up Android SDK
        uses: android-actions/setup-android@v3

      - name: Install SDK components (platform 35 & build-tools 35.0.0)
        run: |
          yes | sdkmanager --licenses >/dev/null
          sdkmanager "platform-tools" "platforms;android-35" "build-tools;35.0.0"

      # 4) Gradle로 빌드 (래퍼 없음 → 액션에서 버전 지정)
      - name: Build with Gradle (assembleRelease)
        uses: gradle/gradle-build-action@v3
        with:
          gradle-version: 8.9
          arguments: assembleRelease

      # 5) APK 업로드
      - name: Upload APK
        uses: actions/upload-artifact@v4
        with:
          name: Soi-Tetris-APK
          path: app/build/outputs/apk/release/app-release.apk
